3章 レスポンスデータの設計

## データフォーマット

- JSONにするのが良い
- ほとんどがJSONにしてるがAmazonだけがXMLだけになっている

### データフォーマットの指定方法

- クエリパラメータを使う方法
- 拡張子を使う方法
- リクエストヘッダでメディアタイプを使う方法

最もお行儀のよい方法はメディアタイプを指定する方法だが、ほとんどの大手サービスはクエリパラメータを使う方法を使っている

クエリパラメータを使う方法のメリット

- 手軽で見た目にわかりやすい
- 初心者にやさしい
- 省略可能であることがわかりやすい

## JSONPの取り扱い

JSON with paddingの略で以下のようにJSONにそれをラップするJavaScriptを付け加えたものを指す

```
callback({"id": 123, "name": "Saeed"})
```

callbackという関数はJSONPを呼び出したscript要素の存在するページにあらかじめ用意しておく必要がある

```
<script src="https://api.example.com/v1/users?callback=callback">
```

**なぜこの方法が考案されたか**

- XHTTPRequestは同一生成元ポリシーの制限によって、同じ生成元（ドメインなど）へのアクセスしか行うことができないから
- でもscript要素は同一生成元ポリシーの規制の対象外のため、JSONをscript要素を使ってJavaScriptとして読み込めば、ドメインを超えたアクセスが可能

ただし、JSONPはGETしか使えずPOSTを利用できない、HTTPヘッダを独自に設定することができないなどの問題はある

### JSONPをサポートする場合の作法

グローバル変数に格納する方法もある

```
var apidata = {"id": 123, "name": "Saeed"};
```

コールバック関数の名前はクエリパラメータを指定できるようにするのが一般的

```
<script src="https://api.example.com/v1/users?callback=cfunc">
```

関数名を指定可能にすると良い理由は2つある

- コールバック関数がグローバル空間に置かれるため、コールバック名を決め打ちにしてしまうと、その名前がページ内の他の関数と衝突する可能性がある
- 同じAPIを複数買いアクセスする場合に、それぞれを異なるコールバック関数にすることで、返されたデータがどのリクエストによって得られたものか区別することができるようになる

JSONPを配信する際の注意点は、JSONPはJSONではなくJavaScriptなので、Content-Typeヘッダにセットするメディア・タイプがapplication/jsonではなくapplication/javascriptになる点

### JSONPとエラー処理

大きな問題点として、サーバがエラーを返した際に正しく反応できないというものがあるので、エラーが発生しても200のステータスコードを返し、レスポンスボディでエラーの内容を表現することでこれに対応する

```
{
  status_code: 404,
  error_message: "User Not Found"
}
```

## データの内部構造の考え方

APIのアクセス回数がなるべく減るようにすることを考える必要がある

### レスポンスの内容をユーザが選べるようにする

- すべてのAPIでできるかぎり多くのデータを返す
- 送受信されるデータのサイズはできるだけ小さい方が望ましい

上記の矛盾を解決する方法

- 取得する項目を利用者が選択可能にするという方法
- あらかじめいくつかの樹徳する項目の量の異なるセットを用意しておく

例)
AmazonのProduct Advertising APIではレスポンスグループとして「Small」「Medium」「Large」を用意している

### エンベローブは必要か

エンベロープ（封筒）例）

```
{
  "header": {
    "status": "success",
    "errorCode": 0,
  },
  "response": {
    ...実際のデータ...
  }
}
```

- 冗長であるためやるべきではない
- HTTPがエンベロープの役割を果たしている
- JSONPは利用した方が便利

### データはフラットにするべきか

- なるべくフラットにしたほうがよいけど、階層構造を持ったほうがわかりやすい場合もある（GoogleのJSON Style Guide）

無駄に階層構造をもつとJSONのデータサイズが大きくなるから不要な階層化はするべきでない

### 配列とフォーマット

- JSONオブジェクトは順序が考慮されない
- JSONには配列の仕様があるからそれを利用する
- 配列をそのまま返す方法とレスポンス全体をオブジェクトにしてその中に配列を入れる方法がある

返す方法はどちらでもさほど変わらないが筆者は以下の理由からオブジェクトで包む方法をすすめている

- レスポンスデータが何を示しているものかがわかりやすくなる
- レスポンスデータをオブジェクトに統一することができる
- セキュリティ上のリスクを避けることができる

トップレベルが配列であるJSONは、JSONインジェクションという脆弱性に対するリスクが大きくなるという問題を抱えている

### 配列の件数、あるいは続きがあるかをどう返すべきか

取得するデータが全体で何件あるかという情報は処理が重くなりがちで工夫が必要になるので本当に件数を返すことが必要かは見極める必要がある。

'続きがあるのか'を取得するために全体の件数を使わず、20件返すために最大21件取得してみて21件取得できれいれば'続きがある'と返す方法もある。そして、続きがあるかという情報を「hasNext」といった名前で結果に含める

'続きがあるのか'を返すだけでなく、次のページのURIや次のページに必要なパラメータを返すパターンもある

## 各データのフォーマット


## エラーの表現

### ステータスコードでエラーを表現する

- HTTPレスポンスの先頭行につける
- 200や404など

```
HTTP/1.1 200 OK
Server: GithHub.com
```

- 100番台：情報
- 200番台：成功
- 300番台：リダイレクト
- 400番台：クライアントサイドに起因するエラー
- 500番台：サーバサイドに起因するエラー

### エラーの詳細をクライアントに返す

- レスポンスヘッダに入れる方法とレスポンスボディに入れる方法があるがレスポンスボディに入れる方法で問題ない
- レスポンスボディの内容はエラーを配列で返すと複数のエラーが同時に発生した場合に合理的な方法になる。

### エラー詳細情報には何を入れるべきか

- 詳細エラーコードの付け方はAPIごとに勝手に決めて良い
- ステータスコードと区別する為に4桁の数字にすると便利

### エラーの際にHTMLが返ることを防ぐ

- 500、503、404などのエラーでHTMLが返ることが多い

### メンテナンスのステータスコード

- メンテナンスする場合は503を返す
- Retry-AfterというHTTPヘッダを使ってメンテナンスが終わるのを示す

### 意図的に不正確な情報を返したい場合

- SNSやチャット系のサービスの場合はブロック機能などがあるので正確な情報を返さないパターンもある

